Characteristics:
  Dynamically typed
  Intended for scripting and as a replacement for the shell

Basic types:
  Int - unlimited-precision integer
    0
    5
    -5
    0xff //hexadecimal
    0b10 //binary
  Float - double-precision floating-point
    3.14
    1e100
  Char - UTF-8 char
    'a'
    '\n'
    '\xa0' //hexadecimal
  Bool - true/false
  Identifier
Composite types:
  Tuple - comma-separated, in parens
  List - comma-separated, in brackets
  Stream - generates one item at a time, on-demand; used for pipes
  String - UTF-8, immutable


Syntax:
  Comments:
    Single-line: //
    Nested multiline: /* */
  Constants: x = 5
  Functions:
    f x = x + 1
      Translated to "f = x => x + 1"
    f ?x:2 = 5
      Optional parameter; called like "f 10" or just "f"
    f x? = !x
      Flag; called like "f 'x"
    f xs* = xs.sum
      Varargs
  Calling a function with keyword arguments:
    f x:8
  Anonymous functions: x => x + 1
    Translated to:
      new {
        x => x + 1
        o g = //composition
      }
  Variables:
    var x <- 10
    println x //prints 10
    x <- 5
    println x //prints 5
  Block: surrounded by {}
    Evaluates its statements in order; returns its last expression
  Object: defined by the "new" keyword followed by a block, or an object followed by the "with" keyword followed by a block (which uses the first object as a prototype)
  ADT:
    data Name param1 param2 = {block}
    data Name param1 param2 = obj with {block}
  Pipes:
    a | b | c
    Equivalent to c (b (a))
  Semicolons aren't required, but are allowed; each newline is treated as a semicolon
  Operators must use special characters; they take exactly 2 arguments and have a predefined precedence and associativity; the rule is the same as in Scala
  Only operators can contain special characters

Evaluation semantics:
  At evaluation time, all functions have been converted into objects. For instance, "a b => a+b" is translated into:
    new {
      a => new {
        b => a+b
      }
    }
    (But with additional things such as composition added)
    When passing "5" to this object, it sees that it matches "a", so it returns an object that adds 5 to its parameter.
    A more complicated example is "a b:5 c:6 = a+b+c. This is very hard to translate into the given form. I think I'll abandon this system - functions can't easily be translated into objects. It doesn't make much sense, anyway; otherwise 1+2 could be written as 1.+.2, which makes no sense. Instead, there is a distinction between functions and objects. Objects can only take fields as parameters, which also means that there is no ambiguity between "a.x" and "a x", so there's no need for the former syntax! Functions aren't evaluated until all their arguments have been grouped together, and then the different versions of the function are checked to see which one matches the given arguments. If none match, or if several match, it's an error.
  The language is evaluated strictly, the one exception being streams, which are evaluated as-needed.
  Function can take any number of arguments, but they are called via juxtaposition. While a function is being evaluated, all possible overloadings are considered. The end of the argument list is decided only when a delimiter is encountered. Examples:
    a = f 1 2 //This has no delimiters; if f takes additional arguments, a will too
    b = (f 1 2) //This has parens as delimiters; f must take only 2 args
    c = { //Newlines/semicolons inside blocks (but not outside) act as delimiters too
      f 1 2
      f 5 6
    }
  Pattern matching:
    Primitives, strings, possibly some collection types, and "data" declarations can be pattern matched.

Temp:
x = 5
a = new {x => x+1; x = 2}
a x //6
a.x //2
a 10 //11
a.10 //11
a (x+1) //7
a.(x+1) //error

b = new {y = 2}
b.y //2
b y //y isn't in scope, so this is equivalent to b.y
b 10 //error
b.10 //error

In-depth example:
  fac n = product (1 to n)
  println (fac 5)
This is evaluated as follows:
  'fac' is defined as a function that takes a value and substitutes it into "product (1 to n)".
  When "fac 5" is called, it sees that it's delimited and so it evaluates it. fac 5 has the delimited expression "1 to n", which evaluates to "[1 2 3 4 5]". In the place of "fac 5", it substitutes "product [1 2 3 4 5]". Since the parens are there, this too is delimited, and evaluates to 120. Then "println 120" is delimited by the newline at the end, so it prints it.

  This does disallow certain syntax like "(map f) xs". However, I think that's okay, because of what I gain. I can have the syntax _* to mean that you're NOT done providing arguments, but this should be used very rarely. I could add a special case to allow syntax like "(map f) xs" in the case where it's not overloaded and it has no optional or repeated parameters, but that could break a lot of code if you add an overloading later. If you really really need this syntax for some reason, you can always do "f a = b => a+b".

f a b = a+b
(f 5) 4 //error - too few arguments to f
f 5 4 //okay

f a = b => a+b
(f 5) 4 //OK
f 5 4 //error - too many arguments to f

What about chains of function calls? Like "Vec2 2 3 add (Vec2 4 5)"? That would have to be written as "(Vec2 2 3) add (Vec2 4 5)". It may not look too bad for this example, but what about "xs map (_+1) filter (_%2==0) sum". That would be "((xs map (_+1)) filter (_%2==0)) sum". Perhaps the pipe operator could be reused: "xs map (_+1) | filter (_%2==0) | sum". "Vec2 2 3 | add (Vec2 4 5)". It would be nice if the other use of the pipe operator could be removed in favor of this syntax - this can be done by allowing you to define methods of the form "obj:fn params" instead of "fn obj params". I'd like a cleaner syntax for that, though.

Pattern matching should allow you to test the type of a value with the syntax "name:Type". For instance, this would allow you to define a factorial method for integers:
  extend 0 fac = 1
  extend n:Int fac = n * (n-1) fac
Interepreting this is going to be fairly simple: these are simply treated as additional overloadings of those methods, except that if there's a conflict between a builtin method and one added in this manner, the former takes priority. I'd like to find a better syntax for this.

a | b | c == ((a) b) c

obj:write x = ...

Allow single quoted strings!

Don't forget to include features like command history and tab-completion!

Make it fairly easy to express things like "(a | b; c ) | something >result"

Have a look at http://ipython.org/

Include * syntax as in bash? Maybe use "ls 'png'" to mean the same as "*.png"

Must be strongly typed, but not statically typed.

By-name definitions are allowed, which can be applied to things like "~x = 5" and parameters. They aren't evaluated until they're actually used.

A type is an identifier. In "data Color r g b", the type is "Color". It must, however, be pattern matched by "Color r g b"

Let's implement the rest of the language first, and then worry about types and pattern matching.

There needs to be a syntactic distinction between values and functions that take no arguments. Values store a single result; functions of no arguments are recalculated each time they're used.
  f = println "Hello world" //won't work
  ~f = println "Hello world" //works foine

  pi = 3.14
  val pi = 3.14
  fac n -> n * fac (n-1)

By-name parameters need to exist, but it makes no sense to allow by-name values in other places. However, zero-argument functions can use the same syntax, which is prepending a ~ to the name.


Perhaps, when an identifier isn't associated with a value, the program should look in the current directory for any executable with that name. This would make it very simple to call existing programs.

From inside the REPL, it should be possible to define a function and then save it to a file. This will be tricky because it'll also have to save every referenced identifier. Alternatively, it should save the state of the REPL from one run to the next, so you pick up right where you left off. However, how does this interact with having multiple shells open at once? And it's not quite as simple as copying all the commands you've executed to a file; the REPL allows you to redefine things while the normal language doesn't. It would be ridiculous to reexecute every instruction that you've ever typed in order to recover the state, so the only option is to somehow store the current state of the environmeent. That's tricky, since the environment is enclosed in IORefs, but it's possible to get rid of them before saving. A bigger problem is saving/loading primitives. However, that can be solved by saving the name of the primitive instead of the primitive itself, but it'll be somewhat tricky to restore properly.

TODO: add sections, tuple sections

TODO: disallow "=" syntax for functions. 

It should be possible to use either "=" or "->" for data declarations. "data Empty = {...}" and "data Empty -> {...}" are very different. However, the second one looks a bit strange, so I'd like a better syntax for it.
